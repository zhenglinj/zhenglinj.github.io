---
typora-root-url: ../
title: "Leetcode算法小结 | 常见"
categories: "technology"
tags:
  - leetcode
  - algorithm
---

本文记录了笔者的一些Leetcode刷题经验，Leetcode题目，适合有一定算法基础的朋友参考。欢迎拍砖。

---

## 如何科学刷题

作为一个优秀的程序员刷Leetcode题目时，一般要求在30min以内完成。题外话推荐一个浏览器计时插件小番茄[Pomodoro® time management assistant](https://github.com/schmich/marinara)。插件默认每25min工作时间提醒，后续5min休息时间提醒。

以下总结归类了类似的问题，进行算法分类，并且给出简单的算法模版，同时结合例子分析。

## 线性表扫描



## 深度优先搜索



## 广度优先搜索

1. 是求路径长度，还是路径本身 

   (a) 如果是求路径长度，则状态里面要存路径长度(或双队列+一个全局变量) 

   (b) 如果是求路径本身

     - 要用一棵树存储宽搜过程中的路径
   
     - 是否可以预估状态个数的上限？能够预估状态总数，则开一个大数组，用树的双亲表示法；如果不能预估状态总数，则要使用一棵通用的树。这一步也是第 4 步的必要不充分条件。 
   
2. 如何表示状态

   即一个状态需要存储哪些些必要的数据，才能够完整提供如何扩展到下一步状态的所有信息。一般记录当前位置或整体局面。 

3. 如何扩展状态

   这一步跟第 2 步相关。状态里记录的数据不同，扩展方法就不同。对于固定 不变的数据结构(一般题目直接给出，作为输入数据)，如二叉树，图等，扩展方法很简单，直接往下一层走，对于隐式图，要先在第 1 步里想清楚状态所带的数据，想清楚了这点，那如何扩展就很简单了。 

4. 关于判重，状态是否存在完美哈希方案

   即将状态一一映射到整数，互相之间不会冲突。 

   (a)  如果不存在，则需要使用通用的哈希表(自己实现或用标准库，例如 unordered_set) 来判重；自己实现哈希表的话，如果能够预估状态个数的上限，则可以开两个数组，head 和 next，表示哈希表，参考第节方案 2。 

   (b)  如果存在，则可以开一个大布尔数组，作为哈希表来判重，且此时可以精确计算出状态 总数，而不仅仅是预估上限。 

5. 目标状态是否已知

   如果题目已经给出了目标状态，可以带来很大便利，这时候可以从起始 状态出发，正向广搜;也可以从目标状态出发，逆向广搜;也可以同时出发，双向广搜。 

**代码模板**  

```python
visited = set()

def bfs(root, visited):
  previous = []
  current = []
  
```



广搜需要一个队列，用于一层一层扩展，一个 hashset，用于判重，一棵树(只求长度时不需 要)，用于存储整棵树。 

对于队列，可以用 queue，也可以把 vector 当做队列使用。当求长度时，有两种做法: 

1. 只用一个队列，但在状态结构体 state_t 里增加一个整数字段 step，表示走到当前状态用 了多少步，当碰到目标状态，直接输出 step 即可。这个方案，可以很方便的变成 A* 算法， 把队列换成优先队列即可。 
2. 用两个队列，current, next，分别表示当前层次和下一层，另设一个全局整数 level，表 示层数(也即路径长度)，当碰到目标状态，输出 level 即可。这个方案，状态可以少一个字 段，节省内存。 

对于 hashset，如果有完美哈希方案，用布尔数组 (bool visited[STATE_MAX] 或 vector<bool> visited(STATE_MAX, false)) 来表示;如果没有，可以用 STL 里的 set 或 unordered_set。 

对于树，如果用 STL，可以用 unordered_map<state_t, state_t > father 表示一颗树，代码非 常简洁。如果能够预估状态总数的上限(设为 STATE_MAX)，可以用数组 (state_t nodes[STATE_- MAX])，即树的双亲表示法来表示树，效率更高，当然，需要写更多代码。 

## 贪心



## 动态规划

